# Chapter07 链接Linking

## 7.1 编译器驱动程序

贯穿本章的两个源文件：

```c
/*sum.c*/
int sum(int *a,int n)
{
    int i,s=0;
    for(i=0;i<n;i++)
    {
		s+=a[i];
    }
    return s;
}

/*main.c*/
int sum(int *a,int n);

int array[2] = {1,2};

int main()
{
    int cal = sum(array,2);
    return val;
}
```

编译器驱动程序指的是驱动调用各类程序进行程序构造的程序。比如GNU编译系统中的编译器驱动程序就是GCC。

一个程序由源代码到可执行文件，需要经过以下步骤：

**预处理、编译、汇编、链接。**从源代码到去除了#include等的中间文件，再到汇编代码、再到可重定位目标文件、再到可执行文件。

执行时shell调用操作系统中的一个叫做**加载器**的函数，将代码和数据复制至内存然后转移控制权。

## 7.2 静态链接

静态链接器以一组可重定位文件和命令行参数作为输入，生成一个完全可执行的文件作为输出。

静态链接主要完成两个任务：**符号解析**和**重定位**。

接下来详细描述这些任务。

## 7.3 目标文件

可重定位目标文件、可执行目标文件、共享目标文件。

编译器和汇编器生成可重定位目标文件，链接器生成可执行文件。

## 7.4 可重定位的目标文件

ELF文件格式：

1. ELF文件头
2. text段，存放代码
3. rodata段，只读的数据
4. data段，已经初始化的全局和静态C变量。局部变量在栈中保存。
5. bss段，未初始化的全局和静态变量，以及所有呗初始化为0的全局或静态变量。在目标文件中不占空间，运行时分配空间并全部设置为0.
6. symtab段，符号表，存放函数和全局变量的信息。
7. rel.text段，记录需要重定位的代码位置，在可执行文件中一般省去该部分
8. rel.data段，记录需要重定位的变量位置。
9. line段：C源程序中的行号与text节中机器指令的映射
10. strtab段：字符串表，内容包括symtab和debug中的符号表，以及节头部中的节名字，字符串表是以null结尾的字符串的序列。

## 7.5 符号和符号表

一个可重定位文件可以视为一个目标模块。每个目标模块m都有一个符号表。有三种不同的符号：

1. 由模块m定义并能被其他模块引用的**全局符号**

2. 由其他模块定义并被m引用的**全局符号**

3. 只被m定义和引用的局部符号，对应于带static的变量。

   符号表不包含栈中的局部变量。

符号表是一个由条目组成的数组，每个条目是一个结构体，包括name、value、section等字段。每个符号都会分配到目标文件的某个节中。可重定位文件中包含3个伪节：ABS代表不该被重定位的符号；UNDEF代表未定义的符号；COMMON表示还未被分配位置的未初始化的数据目标。COMMON和 .bss的区别在于，COMMON表示未初始化的全局变量，.bss存放未初始化的静态变量以及初始化为0的全局或静态变量。COMMON段存在的作用是在符号解析的过程中，如果是未初始化的弱符号，就定义为COMMON符号交给链接器去选择，如果是初始化为0的全局变量则可以放入.bss段。

## 7.6 符号解析

连接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件中的一个确定的符号定义关联起来。编译器会对各个目标文件生成一个符号条目表交给链接器来处理。

对于本地局部变量的符号解析是简单的，但是对于定义在不同模块的全局变量来说是困难的。如果多个符号具有相同的名字，则需要进行取舍。

### 7.6.1 链接器如何解析多重定义的全局符号

1. 不允许多个同名强符号
2. 一个强符号和多个弱符号同名，取强符号
3. 如果有多个弱符号，则从弱符号中任选一个。

书中给出5种实例，关于强弱符号引起的可能的错误，在ubuntu20.04版本中自带的gcc是全部报错的，编译器y一撮i报出错误的方式规避了这类情况。

### 7.6.2 与静态库链接

静态库是一组目标文件，其包含了一些通用的函数的定义。在Linux系统中，静态库以一种称为**存档（.a）**的特殊文件格式存放在磁盘中，是一组连接起来的可重定位文件的集合。链接时加入静态库可以将调用的函数代码部分抽取添加进最终的可执行文件中，然后将不需要的部分丢弃。

### 7.6.3 链接器如何使用静态库来解析引用

在Linux的符号解析过程中，目标文件和静态库文件按照顺序输入命令行。链接器维护三个集合：E表示可重定位文件的集合；U表示未定义未解析的符号集合；D表示已经被定义解析的符号集合。解析过程如下：

1. 顺序扫描输入文件，判断是目标文件还是库文件：如果是目标文件，则将其中的符号读取，更新U和D集合，将该文件添加到E，进行下一个文件的扫描。
2. 如果是存档文件：则尝试在U集合中找到能够匹配的定义；如果找到了某个目标模块m，则将其添加进E集合，并修改U和D。存档中所有文件扫描完毕后没有匹配的目标文件则被丢弃。
3. 全部输入文件扫描完毕后如果U非空，则返回错误，否则将E中的文件整合成为一个可执行文件。

由过程中可以得到，存档文件的输入需要在目标文件之后，否则会出现符号无法解析的情况。

## 7.7 重定位

### 7.7.1 重定位条目

每当汇编器遇到一个最终位置无法确定的引用时，就会生成一个**重定位条目**放进.rel.text节或.rel.data节中。

常见的两种重定位类型对应于PC相对寻址和绝对地址寻址。

重定位条目是一个特殊的数据结构，其结构如下：

```c
typedef struct{
	long offset;//重定位位置在所在的节的偏移量
    long type:32,symbol:32;//type 表示重定位方式，PC相对寻址或者绝对地址寻址；symbol的值为引用符号
    long addend;//一个有符号常数，计算时需要添加该偏移量
}ELF_Rela;
```

课本中研究两种重定位方式：32位地址的PC相对寻址和32位地址的绝对地址寻址。

### 7.7.2 重定位符号引用

重定位算法的伪码可以如下所示：

```c
for each section s{
    for each section r{
        refptr = s+r.offset;
        
        //PC relative
        if(r.type == R_X86_64_PC32){
            refaddr = ADDR(s) + r.offset;
            *refptr = (unsigned)(ADDR(r.symbol) + r.addend -refaddr);
        }
         
        //directly
        if(r.type == R_X86_64_32){
            *refptr = (unsigned)(ADDR(r.symbol) + r.addend );
        }
    }
}
```

其中ADDR（s）或者ADDR（r.symbol）函数功能为返回节的起始地址或者符号的运行时地址。

## 7.8 可执行目标文件

可执行目标文件的格式类似于可重定位文件，但是在ELF头后新加入了一个段头表，记录连续的节映射到内存中的内存段。例如：

1. 只读段：包括ELF头、段头表、init段、text段、rodata段
2. 读写段：包括data段和bss段
3. 不加载到内存的段：包括调试信息、字符串表、符号表等

每一个段头节点还有一些信息，比如偏移量、内存地址、文件大小、内存大小、访问权限、对齐要求等。

## 7.9 加载可执行文件

## 7.10 动态链接共享库

静态链接库的一个问题是，当多个程序都使用同一个库中的内容时，都需要将完全相同的内容添加至可执行文件中，而在多个进程运行时则需要全部添加进内存当中，所以会造成严重的内存浪费。因此动态链接共享库的提出来解决这个问题。共享的意思为所有的进程共享这一块数据和代码。

动态链接的过程是由链接器先将目标文件和共享库中的重定位信息整合，然后在加载器加载可执行文件到内存中时，启动动态链接器；将库中的代码移动至内存中，并将目标文件重定位。

## 7.12 地址无关代码

PIC的作用是为共享库的代码提供一种编译方法，使得共享库可以加载到内存的任意位置。

