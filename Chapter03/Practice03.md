# Practice03 机器级编程

本文档收录比较易错或值得记录的练习题。

## 3.3

以下的汇编语句都是有错误的，找出每一句的错误所在。

1. movb $0xF, (%ebx) 不能将%ebx寄存器作为地址寄存器。ebx寄存器是用于存放内存寻址的基地址，不能将其赋予立即数。
2. 应当是传送一个四字，应当是movq指令。代码后缀与传送数据大小不匹配。
3. mov不允许两个操作数同时为内存操作数。
4. 没有%sl这个寄存器
5. 立即数和寄存器的顺序倒置了，不能将立即数作为目的操作数
6. 目的操作数的大小不匹配
7. %si应为一个w，代码后缀与传送数据大小不匹配

## 3.11 

xorq %rdx ,%rdx

A：这条指令的效果是将rdx寄存器的值置为全0.

B：更直接的表达这个操作的汇编代码是：movl  $0,%rdx

C：使用xor指令比使用mov指令的字节长度更短。任何更新低位4字节的指令都会把高位的4字节置为0（即后缀为l的所有指令）。

## 3.13

该题没有想象中那么简单，需要先判断set指令的种类，然后反推符合条件的data_t类型。

A：cmpl&setl，setl是有符号小于语句，因此需要一个有符号的四字节数，则必然是int类型。

B：cmpw&setge，setge是有符号的大于等于，因此需要一个有符号的2字节数，则必然是short类型

C：cmpb&setbe，setbe是无符号的低于或相等，因此需要一个无符号的单字节数，则必然是unsigned char类型

D：cmpq&setne，setne是不相等，不区分是否为有符号数或者无符号数，因此只需要满足8字节类型即可，因此可能是long、unsigned long、任意的指针。

## 3.14

于3.13思路一致，cmp和test的区别没有影响该题的判断方式。

## 3.16 

A：goto版本的分支控制不熟悉，特此记录。

B：if语句中有两个条件取与操作，因此进行分支判断，如果前面条件不符合的情况下可以不再判断后一条件而直接进行跳转。

## 3.18 

填写C代码。

code here

## 3.19 

A：处罚时间为2 * （Tran-Tok） = 2*（31-16） = 30

B：错误时间为Tok +Tmp == 30 + 16 = 46

## 3.20

A：OP进行的是除法操作：需要先添加偏移，然后测试是否是负数，如果不是负数，则将寄存器置为原来的值，然后进行算术右移。

## 3.21 

条件传送要比条件控制难一些。

code here

## 3.22

如何检测溢出？回想第二章的内容，检测乘法溢出的方式是检测mul/b==a

code here

## 3.23

A：%rax、%rcx、%rdx寄存器分别用来存放x、y、n。

B：程序中实际上没有用到指针的地址。解引用语句改为x++即可。

## 3.24

code here

## 3.31

code here

## 3.32

| 标号 | PC       | 指令      | %rdi | %rsi | %rax | %rsp           | *%rsp    | 描述                 |
| ---- | -------- | --------- | ---- | ---- | ---- | -------------- | -------- | -------------------- |
| M1   | 0x400560 | callq     | 10   | -    | -    | 0x7fffffffe820 | -        | 调用first（10）      |
| F1   | 0x400548 | lea       | 10   | 11   | -    | 0x7fffffffe818 | 0x400565 | 将x+1放在%rsi中      |
| F2   | 0x40054c | sub       | 10   | 11   | -    | 0x7fffffffe818 | 0x400565 | 将x-1放在%rdi中      |
| F3   | 0x400550 | callq     | 9    | 11   | -    | 0x7fffffffe818 | 0x400565 | 调用last（x-1，x+1） |
| L1   | 0x400540 | mov       | 9    | 11   | -    | 0x7fffffffe810 | 0x400555 | 将u放入%rax中        |
| L2   | 0x400543 | imul      | 9    | 11   | 9    | 0x7fffffffe810 | 0x400555 | 计算u*v并放入%rax中  |
| L3   | 0x400547 | retq      | 9    | 11   | 99   | 0x7fffffffe810 | 0x400555 | 返回first中          |
| F4   | 0x400555 | repz retq | 9    | 11   | 99   | 0x7fffffffe818 | 0x400565 | 返回mian中           |
| M2   | 0x400565 | mov       | 9    | 11   | 99   | 0x7fffffffe820 | -        | 继续main部门         |

## 3.33

首先将edi中的参数通过符号扩展从32到64位，然后与%rdx中的内存中的值进行四字加，因此第一个参数是有符号的4字节的数据类型，必然是int。对应的第三个参数rdx必然是一个64位数据类型的指针，因此必然是long*。另一边两个数据类型的字节长度一共为6，int占了4字节，2字节的有符号类型必然是short类型。但是加法指令是addb，是单字的，因此指针所指的数据类型是一个char类型。因此一个合法的答案是：int a，short b，long *u，char * v。对应的，不改变数据类型的顺序而两两对调整数和指针的顺序也是合法答案。
