# Chapter03 程序的机器级表示

## 3.1 历史观点

x86代表一系列以86结尾的芯片名称。

摩尔定律：同一个面积上的晶体管数目每隔26个月就会翻一番。

## 3.2 程序编码

对于不同的优化等级，-Og是生成符合原始C代码整体结构的机器代码的优化等级，因此以-Og作为学习工具。实际性能来说，较高级别的-O1或者-O2是更好的选择。

### 3.2.1 机器级代码

机器级编程有两种重要的抽象：一种是**由指令集体系结构或者指令集架构**来定义机器级程序的格式和行为；另一种抽象是**内存地址是虚拟地址**。

常用的寄存器有**程序计数器PC，整数寄存器文件（16个），条件码寄存器，一组向量寄存器**（存放一或多个整数或者浮点数）。

### 3.2.2 代码示例

跟随课本所给出的示例进行汇编，所得到的汇编代码的反汇编结果与课本示例均不同。使用相同的源代码进行编译、汇编和反汇编，结果全部上传。

### 3.2.3 关于格式的注解

所有以.开头的行都是知道汇编器和连接器工作的伪指令。通常可以忽略这些消息，因为这些消息与源代码没有直接的关系。

关于AT&T格式和Intel格式的不同点：

1. Intel代码省略了表示字的大小的后缀，如movq和movl统一为mov
2. intel省略了寄存器前的%，直接使用寄存器的名称
3. Intel代码使用地址加偏移的方式表示内存中的值而非使用括号
4. Intel代码与AT&T代码的操作数顺序相反。

## 3.3 数据格式

**字word**表示16位的数据类型，这是因为最初是从16位体系结构扩展而来。因此32位被称为双字double word，64位被称为四字quad word。大小为1、2、4、8的整数值在汇编语言中的代码后缀分别为b、w、l、q，对于浮点数分别是4字节的float使用s，以及8字节的double使用l。

## 3.4 访问信息

一个x86-64的CPU包含一组16个64位的通用目的寄存器，用于存储整数数据和指针。对应r开头的是完整的64位寄存器，e开头的是低32位，对应的还有16比特和8比特的寄存器。

### 3.4.1 操作数指示符

操作数分为三种类型：**立即数，寄存器，内存引用**。关于内存寻址中寄存器与内存的关系表如上。

### 3.4.2 数据传送指令

将数据从一个位置移动到另一个位置。mov指令类，都是完成相同的操作，区别在于操作的数据大小不同。MOV S，D，效果是将Source传送至Destination。如果操作数是一个立即数I和一个内存地址R，则是将立即数传送至内存地址中。但是**数据传送指令的两个参数不能同时为内存地址**。从一个内存位置复制到另一个位置需要两条指令。其中movl指令在传送以寄存器为目的时，会将高32位默认置为0。

MOVZ和MOVS是另外两类指令，将较小的源值复制到较大的目的使用，只能从源复制到寄存器中。MOVZ通过填充0，而MOVS使用符号扩展。指令后跟两个字母，分别代表转换前后的数据类型。

练习题3.3值得分析，要清楚理解为什么这些指令是错的，错在何处。

### 3.4.3 数据传送示例

更换了64位的ubuntu来运行示例代码，可以得到与课本相同的代码。

关于练习题3.4，其实解题思路全部相同：从内存中提取数字时如果需要位扩展则进行对应的mov扩展，向较短的位移位时则只需使用小的寄存器。

### 3.4.4 压入和弹出栈数据

压栈和弹栈操作都是一系列操作，push的操作数是源操作数，pop的操作数是目的操作数。

## 3.5 算术和逻辑操作

大多数操作也被分成了指令类。根据操作类型可以分为四组：加载有效地址、一元操作、二元操作和移位。

### 3.5.1 加载有效地址

leaq指令实际上是movq指令的变形，从内存中读取数据到寄存器，相当于C语言中的取地址符，第一个操作数是**一个有效的地址**，目的操作数必须是一个寄存器。

### 3.5.2 一元和二元操作

对于一元操作来说，其操作数又是源又是目的。对于二元操作数的第二个操作数，既是源操作数又是目的。

对于二元操作数来说，第一个操作数可以是立即数、寄存器或者是内存位置，**第二个操作数可以是寄存器或者是内存位置。当第二个操作数位内存地址时，处理器必须从内存中读取值，执行操作，再把结果写回内存。**

### 3.5.3 移位操作

移位操作有两个操作数，第一个是位移量，第二个操作数是要进行移位的数。位移量可以是立即数，若是变量必须要放在单字节寄存器%cl中。对w位长的数进行移位操作，位移量只考虑低log2w位。逻辑移位和算术移位分别有SAL、SHL、SAR、SHR，其中两个左移作用相同。

### 3.5.4 讨论

### 3.5.5 特殊的算术操作

mul和div分别代表乘除法，前缀i代表有符号数，没有前缀i代表无符号数。

mulq可以在两个64位操作数上计算出64位的结果。而如果目的操作数是%rax（隐式的作为参数，实际指令只有一个操作数），其可以计算出完整的128位结果，存放在高位%rdx和低位%rax中。注意要先进行符号扩展在进行运算。除法同理。

## 3.6 控制

### 3.6.1 条件码

条件码寄存器是独立于整数寄存器的一组单个位的寄存器，算术或者逻辑指令会对这些寄存器进行设置，通过检测这些寄存器的值来进行条件分支指令。逻辑、算术、移位操作都会对应的设置条件码寄存器的值，但是lea指令不会。

cmp和test都对应有各个字大小的指令版本，cmp指令会通过第二个操作数的值减去第一个操作数的值进行置位，test则通过计算S1&S2.

### 3.6.2 访问条件码

通常条件码不会直接读取，常用的使用方法有三种：

1. 可以根据条件码的组合将一个字节设置为0或者1（结果只有一位0或者1，但是需要最少对一个字节进行操作），这一整类指令被称为Set指令类，通过后缀来区分条件。
2. 可以条件跳转到程序的某个其他的部分
3. 可以有条件的传送数据。

某些条件可能具有相同的含义，如大于和不小于等于实际上是相同的。因此编译器会在功能相同的位置随意的选择。

对于机器语言来说，大多数情况下处理有符号数和无符号数是使用相同的指令，因为二者在机器级上拥有相同的位级行为。而在需要区分的时候，使用不同的指令处理两类数据。

### 3.6.3 跳转指令

jmp是直接跳转，jmp后跟一个*再接一个寄存器是间接跳转至寄存器中的地址。

条件跳转只能是直接跳转。

### 3.6.4 跳转指令的编码

跳转指令最常用的有PC相对跳转和绝对地址跳转。

PC相对寻址的设计原则是，PC计数器指向的指令地址是jmp指令的下一条指令的地址，而jmp指令后跟的数值是想要跳转的指令的地址减去当前PC计数器的地址的这一差值（可以是负数）。这种方式的跳转指令在经过连接后，指令本身不会发生变化，仍然是相对位置的值。

rep和repz的作用是避免ret指令称为条件跳转的目标，对是程序功能不会改变，可以做到无视。

### 3.6.5 用条件控制来实现条件分支

练习题3.18能熟悉该章节运算。

### 3.6.6 用条件传送来实现条件分支

条件传送来实现是传统的方法，程序沿着满足条件的路径执行。但是在线代处理器上运行时会显得比较低效，原因是现代处理器使用了**流水线pipelining**设计。

相比于条件控制的不同点在于，条件传送计算出一个条件的对应的两种情况的结果，然后根据条件是否满足来从中选取一个作为返回值。

因为流水线的设置，处理器会每个阶段不断地执行不同的指令，而当遇到分支条件时，程序会等分支条件完全处理后才能够处理对应方向上的指令。处理器采用非常精确的**分支预测逻辑**来预测每条跳转指令是否能执行。当猜测出现错误时，会将流水线中的工作全部丢弃，然后重新填充正确的指令，对于时钟周期的惩罚是非常严重的。

关于分支预测错误的惩罚推导：
$$
T_{mp} = 2 * (T_{ran} -T_{OK})
$$
其中Tran代表随机状态下的平均时钟周期，Toc是正确执行代码的平均时钟周期，p是预测错误的几率。则有：
$$
T_{avg} = (1-p)T_{OK} + p(T_{OK} + T_{MP})
$$
当随机情况下，p为0.5，则
$$
T_{avg} = T_{OK} + 0.5 *  T_{MP}
$$
转换即可得到。

cmov指令类，是当条件码符合一定条件时，才能从源寄存器或者内存地址S向目的寄存器R中移动数据。

需要注意的是，不是所有的条件语句都可以使用条件传送来实现。因为两种情况的表达式都需要进行求值，因此必须保证两种情况的表达式都是合法的。反之，则必须使用条件控制。如对一个可能为空的指针进行解引用。

条件传送用额外的计算量来减少预测错误的代价，编译器会选择开销更少的方法。事实上，GCC使用条件控制转移更多，即使预测错误的开销更大。

### 3.6.7 循环

1. do-while循环：先执行循环体，然后在进行条件跳转
2. while循环：对于while循环有两种翻译方式：一种是跳转至中间法：直接跳转至do-while循环的判断条件中；另一种是guarded-do翻译法，先反向测试循环条件，如果满足反向条件则直接不进入循环。注意，当GCC采取-O1优化级别时才会采取这种策略，如果使用-Og则仍然会使用基础的跳转至中间法。
3. for循环：C语言标准定义for循环的行为与循环体内更新参数的while循环的行为一致。因此翻译for循环是使用while循环的两种翻译之一。

### 3.6.8 switch语句

对于具有多种可能结果的测试中，这种语句特别有用。使用**跳转表**使得实现更加高效。

## 3.7 过程Procedure

软件中一种重要的抽象，将代码功能封装方便调用。函数function是过程的的一种形式。过程包括下面的机制：传递控制、传递数据、分配和释放内存。

### 3.7.1 运行时栈

对于x86-64，当过程存储空间超出了寄存器能够存放的大小，就会在栈中分配空间，这部分称为栈帧stack fram。寄存器最多可以为过程传递6个整数参数（整数和指针），如果过程需要更多的参数，则需要在栈中传递和存储这些参数。如果函数小且没有其他调用，甚至都不需要构造栈帧。

### 3.7.2 转移控制

call指令完成两个工作：将目前地址的下一条指令地址压入栈中，并跳转至需要调用的函数的起始位置，可以直接或者间接。

### 3.7.3 数据传送

过程需要参数的输入，还需要返回值的输出。

x86-64的寄存器可以按照固定的顺序传输最多6个整数参数。这些数据需要向8字节对齐。

### 3.7.4 栈上的局部存储

前面的所有程序都不需要在栈上开辟额外的空间来存储数据。但是在以下情况中，需要在栈中开辟空间：

1. 寄存器不足以存放所有数据
2. 对局部变量使用了取地址符
3. 某些局部变量是数组或者结构体

### 3.7.5 寄存器中的局部存储空间

由于寄存器是被所有过程共享的，因此当过程调用其他过程时，需要保证被调用者的信息不会被篡改。因此有一组寄存器被称为**被调用者保存**寄存器，器可以保存被调用者过程中的某些数据。

### 3.7.6 递归过程

## 3.8 数组分配和访问

### 3.8.1 基本原则

### 3.8.2 指针运算

指针的加减法是对应加i个数据长度。

由练习题3.37和书中示例可以看出，对于指针直接进行算术的表达式，在汇编代码中一般为leaq指令来执行，除非是将S自身引用时使用movq指令。其他的索引数组中数字的表达式都是使用mov类指令。

### 3.8.3 嵌套的数组

### 3.8.4 定长数组

编译器对于定长数组采用了一种聪明的优化方式，分别使用Aptr，Bptr和Bend来表示连续的行元素、连续的列元素以及循环结束的指针。

### 3.8.5 变长数组

## 3.9 异质的数据结构

### 3.9.1 结构struct

结构中的所有成员在内存中是连续的，指向结构的指针式结构第一个字节的地址。

### 3.9.2 联合

### 3.9.3 数据对齐

不同大小的数据对齐要求的倍数式不同的，每种类型的对齐限制为其本身数据大小。当一个数据结构中有多种元素，全局对其方式为其最大元素。

## 3.10 在机器级程序中将控制与数据结合起来

### 3.10.4 对抗缓冲区溢出攻击

1. 栈随机化：在栈上分配空间但是不使用，会影响后续程序的地址发生变化。地址空间布局随机化ASLR
2. 栈破坏检测：也就是canary机制。带该机制的情况下将变量移动至缓冲区前可以保护不被修改。
3. 限制可执行代码区域：限制栈中不能执行代码，防止攻击代码成功运行。

### 3.10.5 支持变长栈帧

需要在运行阶段才能确定栈帧的长度的情况。因此需要使用%rbp来固定的索引战中的元素，而不是使用可能会发生变化的%rsp栈指针。早期x86都会包含栈指针。目前只有变长栈帧的情况下才会使用%rbp，固定栈帧不会使用%rbp的。leave指令用于恢复%rsp和%rbp。
