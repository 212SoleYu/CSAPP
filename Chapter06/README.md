# Chapter06 存储器层次结构

## 6.1 存储技术

对这些年对于存储器技术的发展简单介绍。

### 6.1.1 随机访问存储器

随机访问存储器，Random-Access Memory，分为两类：静态SRAM和动态DRAM。静态更快更贵，动态反之。SRAM用于制作cache，DRAM则用来做主存以及图形系统的帧缓冲器。

1. 静态RAM--SRAM：使用一个双稳态的存储器单元来保存一个位的值，类似于倒挂的钟摆，当钟摆位于最左或者最右时，单元稳定且一直保持该值。
2. 动态RAM--DRAM：使用单一的晶体管存储一位，对干扰较为敏感容易被改变，因此不是持续的保持某一值。
3. 传统的DRAM：DRAM芯片中的单元被分为d个超单元，每个超单元由w个DRAM组成，d个超单元被组织成为一个长方形二维阵列。每个DRAM芯片被连接到某个称为**内存控制器**的电路，可以通过该电路从DRAM中读一个超单元的数据或者传入一个超单元的数据。因此超单元是按照行和列来进行索引，因此两个索引值先后通过地址引脚传入芯片，读取到的行复制至内部行缓冲区，再根据列索引取出超单元。
4. 内存模块：DRAM芯片封装在内存模块中。多个内存模块连接到内存控制器，能够聚合成**主存**。
5. 增强的DRAM：
   1. 快页模式，
   2. 扩展数据输出
   3. 同步DRAM
   4. 双倍数据速率同步
   5. 视频RAM
6. 非易失性存储器Read-Only Memory：不会因为失电而失去内部信息。闪存是一种非易失性存储器，固态硬盘是基于闪存的。
7. 访问主存：数据流通过总线bus的共享电子电路再处理器和DRAM主存之间来来回回i。这些步骤被称为**总线事务，包括读事务和写事务**。

### 6.1.2 磁盘存储

1. 磁盘构造：

   磁盘是由盘片构成的，盘片的两面称为表面，覆盖着磁性记录材料。盘片中央有一个可以旋转的主轴，以固定速率旋转。表面上的同心圆被称为**磁道**，**磁道**被划分为多个等大小的**扇区**。扇区之间由一些间隙Gap分隔开。多个盘片被封装在一个装置中，被称为**磁盘驱动器**，简称为磁盘。磁盘上所有到主轴距离相等的磁道被称为一个**柱面**

2. 磁盘容量：

   记录密度：磁道上一英寸段可以放入的位数

   磁道密度：盘片中心半径上一英寸内磁道数

   面密度：记录密度与磁道密度的乘积

   磁盘容量=盘片数* 表面数* 磁道数* 平均扇区数* 每扇区字节数，对于磁盘来说1GB=10^9字节

3. 磁盘操作：

   **寻道时间**：磁头定位至指定磁道的时间，平均为3-9ms

   **旋转时间**：到磁头到达指定磁道后等待旋转至目标扇区第一个位的时间，平均时间是盘片旋转一周的时间的一半

   **传送时间**：读取完该扇区所用的时间，取决于旋转速度和当前磁道的扇区数。

4. 逻辑磁盘块：磁盘中的一个装置，负责将磁盘结构抽象给上层。

5. 连接I/O设备：I/O设备通过I/O桥接器连接至主存。

6. 访问磁盘：（与访问内存数据不同），从磁盘中访问数据是很慢的且需要串行等待，这是严重损耗效率的，因此对于磁盘的访问，CPU使用一种名为**内存映射**的技术向I/O设备发射命令。CPU向磁盘发送命令，磁盘控制器接收到后向主存中写入内容，待到主存中的内容完全写入后，向CPU发送一个**中断**，CPU已知I/O完毕，跳转回访问磁盘的进程。磁盘向内存写入的操作不需要CPU干涉，这种数据传送被称为直接内存访问DMA。

### 6.1.3 固态硬盘

SSD是基于闪存的。由若干个闪存芯片和一个**闪存翻译层**（类比于磁盘控制器）组成。一个闪存由B个块组成，一个块有若干页，以页位单位进行读写。只有当页所在的整个块被擦除后，这个页才能被写入数据。但是擦除后整个块所有页都可以进行一次写入。试图进行写操作时块中所有数据必须移动到一个新块中。

SSD的缺点是会产生磨损，但是实际上其寿命在实际的使用情况下已经非常长了。

### 6.1.4 存储技术趋势

不同的存储技术有不同的价格和性能折中。

不同的的存储技术的价格和性能都以不同的速度变化。

DRAM和磁盘的性能滞后于CPU的性能。

## 6.2 局部性Locality

一个良好的计算机程序具有良好的局部性。**时间局部性**表示一个内存位置在引用之后很可能会被再次引用；**空间局部性**表示一个内存位置在引用之后其周围的内存位置很有可能会被引用。

### 6.2.1 对程序数据引用的局部性

一个具有良好局部性的程序：

```c
int sumvec(int v[N])
{
    int i ,sum = 0;
    
    for(i = 0; i < N ;i++)
    {
        sum+=v[i];
    }
    return sum;
}
```

顺序访问内存中的数据，被称为**步长为1的引用模式**，也称**顺序引用模式**。一般来说，步长为1的引用模式是**空间局部性的重要来源**。随着步长的增加空间局部性下降。

由于二维数组是行优先的，因此在双重循环的嵌套中先使用行再使用列同样具有顺序引用模式。

### 6.2.2 取指令的局部性

指令在内存中也需要被提取出来放入CPU，因此也存在局部性。例如for循环中的指令，连续存放故存在空间局部性，for循环多次执行，所以存在时间局部性。**循环体越小，局部性就越好**。

## 6.3 存储器层次结构

由于**不同的存储技术性质不同**以及**良好的程序具有良好的局部性**，因此产生了存储器的层次结构。高层容量小、速度快、价格高，底层容量大、速度慢、价格低，数据在不同层之间传递和保存。cache使用SRAM，主存使用DRAM，还包括磁盘和远程存储。

### 6.3.1 存储器层次结构中的缓存

高速缓存，cache，使用高速缓存的过程称为缓存cashing。

在存储器的层次结构中，每一层都可以作为下一层的缓存层。

1. 缓存命中，表示在缓存中找对应的块成功找到。
2. 缓存不命中，表示在缓存中没有找到想要的数据块，需要到再下一层的存储结构中再次寻找并移动至该层缓存层。移动新数据可能会导致数据覆盖，一般会采取一些算法来实现，如LRU。
3. 缓存不命中的种类：冷不命中（cold miss）或者强制性不命中、容量不命中、冲突不命中（conflict miss）
4. 缓存管理：

## 6.4 高速缓存存储器

再学习讨论的过程中假定只有一个一级缓存cache L1.

### 6.4.1 通用的高速缓存存储器组织结构

缓存的组织形式可以用一个元组（S，E，B，m）来表示：m是地址的位数，参数S和B将m位的地址分为了三个字段：S表示整个cache中的组数，共有S = 2 ^ s个组；B表示一个组中字节块的数目，共有B = 2 ^ b个字节。剩余的m-(b+s)位为标记位，用于标识是否索引的块相等。还有一位有效位，表示这个行是否有效。

### 6.4.2 直接映射高速缓存

高速缓存确定一个请求是否命中，然后抽取出被请求的字的过程，分为三步：组选择、行匹配、字抽取

1. 直接映射高速缓存中的组选择：

   s位的组索引位直接映射到对应组中的唯一一行高速缓存。

2. 直接映射高速缓存中的行匹配：

   因为只有一行，因此当且仅当设置了有效位且标记匹配的情况下再说明缓存命中。

3. 直接映射高速缓存中的字选择：

   根据b位的字偏移量来进行选择行中的起始字节，提取字即可。

4. 直接映射高速缓存中不命中时的行替换：

   如果不命中则需要从存储器层次结构中的下一层取出被请求的块，直接插入cache使用替换策略覆盖一行。

5. 运行中的直接映射高速缓存：4位地址的示例

6. 直接映射高速缓存中的冲突不命中：

   抖动（thrash）表示高速缓存反复的加载和驱逐相同的高速缓存块的组，如下面的示例代码：

   ```c
   float dotprod(float x[8],float y[8])
   {
       float sum = 0.0;
       int i ;
       
       for(i =0;i<8;i++)
       {
           sum+=x[i]*y[i];
   }
       return sum;
   }
   ```

   假设一个块是16字节，cache共有两个组，则x[i]和y[i]总是在直接映射的情况下映射到同一个组，每一次计算乘法都会有两次不命中。

### 6.4.3 组相连高速缓存

1. 组相联高速缓存中的组选择：同样是通过s位的组索引确定对应的组

2. 组相联高速缓存中的行匹配和字选择：在对应的组中寻找有效位和标记位都匹配的行，如果不存在则说明不命中，如果存在则按照字偏移进行读取。

3. 组相联高速缓存中不命中的行替换：

   如果有空行则替换空行，如果没有空行则需要按照一定的替换策略，如随即替换、最不常使用LFU、最近最少使用LRU。

### 6.4.4 全相联高速缓存

顾名思义，cache中只有一个组，所有的地址都可以映射到该组，因此组索引位变为0位。

1. 全相联高速缓存中的组选择：所有的地址都映射到一个组中
2. 全相联高速缓存中的行匹配和字选择：与组相联的一组中一致，只是规模发生了变化。

### 6.4.5 有关写的问题

在缓存中试图修改一个**已经命中**的内存块，有两种方式：**直写（写直达write-through）和写回（write back）**。其中直写的作用是修改缓存块后直接向低一层的内存中写入，优点简单，缺点是总是引起总线流量，速度会变慢；写回的作用是修改内存中的数据，直到该块被替换时将其写回低一层的存储中，优点是减少总线流量，缺点是复杂，需要额外的位记录是否被修改。

当**写不命中**时，两种处理方法分别为**写分配**和**非写分配**。**写分配**时加载块到高速缓存中，更新高速缓存，**非写分配**的作用是直接写入低一层的存储中。因此，**写回策略通常是写分配的，直写策略通常是非写分配的**。

随着技术的发展，写回和写分配的技术难度已经不成问题，大多数存储结构，例如虚拟内存，都使用**写回写分配**的方式。

### 6.4.6 一个真实的高速缓存层次结构的解剖

多级cache、指令cache和数据cache分离实现并发

### 6.4.7 高速缓存参数的性能影响

不命中率、命中率、命中时间、不命中处罚

缓存大小、块大小、相连度、写策略

## 6.5 编写高速缓存友好的代码

1. 让最常见的情况运行的快
2. 尽量减小每个循环内部的缓存不明中数量

## 6.6 高速缓存对程序性能的影响

1. 内存山
2. 改变矩阵乘法顺序来减少不命中