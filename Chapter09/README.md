# Chapter09 虚拟内存

虚拟内存Virtual Memory 是为了更加有效管理内存而提出的一种抽象。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互。

虚拟内存提供了三个重要的能力：

1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存
2. 它为每个进程提供了一致的地址空间，简化了内存管理
3. 它保护了每个进程的地址空间不被其他进程破坏

第九章从两个角度来看虚拟内存，一是描述虚拟内存如何工作，二是在此基础上研究程序如何使用和管理虚拟内存。

## 9.1 物理和虚拟寻址

CPU使用物理地址来从主存中直接索引提取数据，这种方式被称为物理寻址。早期的PC使用物理寻址。现在的计算机都使用虚拟寻址的形式，CPU向一个称作**内存管理单元Memory Management Unit MMU**的内存地址翻译单元发送一个虚拟地址，该单元将虚拟地址对应的映射为一个唯一的物理地址，再从主存中获取数据返回给CPU。

## 9.2 地址空间

地址空间是一个非负整数地址的有序集合，我们假设研究的地址空间都是线性的。

## 9.3 虚拟内存作为缓存的工具

虚拟内存将主存抽象为磁盘存储的高速缓存，因此将虚拟内存和物理内存都按照一个固定的大小P字节来进行划分，这些大小为P字节的内存块被称为**虚拟页Virtual Page**或者**物理页Physical Page**。

虚拟内存的地址空间被划分成所感虚拟页面，这些虚拟页面在任意的时刻都被划分为三个不相交子集：

1. 未被分配的虚拟页，说明程序在虚拟地址空间中没有使用到该部分
2. 缓存的虚拟页，程序使用，并且已经在物理内存中缓存的页
3. 未缓存的虚拟页，程序使用但是没有在物理内存中缓存的页

### 9.3.1 DRAM缓存的组织结构

用SRAM缓存表示cache，用DRAM缓存表示虚拟内存系统的缓存，在主存中缓存虚拟页。

由于DRAM的不命中需要磁盘来处理，因此DRAM的不命中处罚非常昂贵，所以DRAM的虚拟页往往很大，4KB-2MB。DRAM缓存是全相联的，所以DRAM缓存需要更加精密的替换算法。由于磁盘写的时间过长，因此必须采用写回策略。

### 9.3.2 页表

用来确定虚拟页是否在DRAM内存中，且获知具体在哪个位置。页表存放在物理内存中的一个地方，将虚拟页映射到物理页。操作系统负责维护页表的内容，以及在磁盘与DRAM之家来回传送页。

页表就是一个页表条目（Page Table Entry）的数组。**虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE。**我们假设PTE由一个有效位和一个n位地址字段组成，当有效位为1时，地址字段为**物理页**起始地址；有效位为0时，如果地址为一个空地址，说明该页该没有被分配；否则这个地址指向**该虚拟页在磁盘上的起始位置**。由于是全相联，所以虚拟页可以任意的放入页表中。

### 9.3.3 页命中

当想要读取的虚拟页存放在物理内存中时，CPU通过翻译硬件将虚拟地址转换为页表索引，就可以跳转至物理页中进行索引读取。

### 9.3.4 缺页

DRAM缓存不命中被称为**缺页**。读取一个位于虚拟页3中的字。但是在页表中VP3对应的PTE有效位为0，说明没有在DRAM中缓存该页。则需要将VP3从磁盘中移动至DRAM中，通过缺页异常使用异常处理程序。如果DRAM中有空闲位置，则直接放入，如果没有空闲位置则需要按照替换策略更换页。将页面装载替换后回返回导致缺页异常的指令，重新读取数据，此时可以正常处理了。

在磁盘和内存之间传送页的活动叫做**交换**或者**页面调度**。

### 9.3.5 分配页面

操作系统创建新的虚拟页，并将PTE的地址指向该虚拟地址。

### 9.3.6 又是局部性救了我们

虚拟内存的性能实际上表现良好的原因归功于**局部性**。局部性原则保证了在任意时刻程序趋向于在一个较小的活动页面集合上工作，这个集合叫做**工作集**或者**常驻集合**。但是如果工作集的大小超出了物理内存的大小，则将导致页面不断换进换出的情况，称这种情况为**抖动thrashing**。

## 9.4 虚拟内存作为内存管理的工具

每个进程都有自己独立的页表，将一个虚拟地址空间映射到物理地址空间。

1. 简化链接：链接器的连接功能都是基于虚拟地址的，这样就独立于代码和数据在物理内存中的最终位置。
2. 简化加载：加载器只需要分配虚拟页，不向内存复制任何数据，而是通过CPU取指时引发缺页中断来进行页面调度。
3. 简化共享：操作系统创建页表，将相应的虚拟页映射到不连续的物理页面，保证进程之间私有的数据不共享，但是公共函数如库函数可以通过映射至相同页面来实现代码共享。
4. 简化内存分配：操作系统分配连续的内存，这一部分连续的内存可以映射到不连续的物理内存区域，就没有必要寻找到连续的若干物理页面。

## 9.5 虚拟内存作为内存保护的工具

操作系统可以在PTE上添加某一个页的读写权限来进行访问控制，例如防止修改只读页，是否只能在内核态下运行。如果某条指令违反了这些许可条件，CPU回触发一个一般保护故障，一般报告未段错误Segmentation fault

## 9.6 地址翻译

CPU中的一个控制寄存器**页表基址寄存器Page Table Base Register PTBR**指向当前的页表，n位的虚拟地址包含两个部分：一个p位的**虚拟页面位移Virtual Page Offset VPO**和一个（n-p）位的**虚拟页号Virtual Page Number VPN**。

VPN用于确定PTE，VPO和PTE中对应的物理地址起始点来确定实际的数据位置。

当一个页命中时，CPU硬件执行的步骤：

1. 处理器生成一个虚拟地址，传送给MMU
2. MMU得到PTE地址（页表偏移），从高速缓存/缓存中请求得到它
3. 高速缓存/主存向MMU返回PTE
4. 从PTE中构造出物理地址，传送给高速缓存/主存
5. 高速缓存/主存返回所请求的数据字给处理器

而当发生缺页时，需要硬件和软件同时处理：

1. 处理器生成一个虚拟地址，传送给MMU
2. MMU得到PTE地址（页表偏移），从高速缓存/缓存中请求得到它
3. 高速缓存/主存向MMU返回PTE
4. PTE有效位为0，MMU触发缺页异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。
5. 缺页处理程序确定牺牲页，如果该页已经被修改了，则返回到磁盘。
6. 缺页处理程序页面调入新的页面，更新PTE和页表。
7. 重启进程中的指令，重新发送虚拟地址到MMU，MMU这次回按照命中状态继续执行下去。

### 9.6.1 结合高速缓存和虚拟内存

在任何及使用虚拟内存又使用SRAM高速缓存的系统中，都有应该使用虚拟地址还是使用物理地址来访问SRAM高速缓存的问题。实际上大多数系统是选择物理寻址的。地址翻译发生在查找高速缓存之前。

### 9.6.2 利用TLB加速地址翻译

TLB是对于PTE的一个小段缓存，称为翻译后备缓冲器Translation Lookaside Buffer TLB。

其每一行都存储着一个单个PTE组成的块，通常有高度的相连度。设TLB有T = 2^t个组，则使用VPN的低t位进行组索引，剩余的较高位组成标志域。

TLB通常回命中。当TLB命中时，会产生以下步骤：

1. CPU产生一个虚拟地址
2. MMU从TLB查询对应的PTE，命中
3. MMU从TLB获取到PTE
4. MMU将PTE中的地址组成物理地址，发送至高速缓存或主存
5. 从高速缓存或主存中返回数据

如果TLB未命中，则从cache中读出PTE。

### 9.6.3 多级页表

多级页表是用于压缩页表所占用存储空间的一种方式。对于一个32位地址空间，页面大小为4KB的系统，一个PTE大小为4字节，这样一个进程总要有4MB的页表驻留在内存中。而往往一个程序使用的虚拟页面只有其中很小的一部分，且具有很强的局部性。因此为了减少页表占用，提出了多级页表：以二级页表为例，将1024个页面组成为一个**片**，然后一级页表指向的是一个二级页表，二级页表完全对应了一个片中的1024个页。如果一个片中所有的页都未被分配，则该片的一级页表是一个空指针，不存在对应的二级页表，也就不需要占用内存。且常驻内存的只有一级页表，也减少了内存消耗。

对于多级页表的索引，根据每一级的页表的大小对VPN进行多段划分。

### 9.6.4 综合：端到端的地址翻译

索引过程，跟随示例研读

## 9.7 案例研究：Intel Core i7/Linux内存系统

### 9.7.1 Core i7地址翻译

Linux Corei7的处理器封装：

![image-20220827100904063](C:\Users\10332\AppData\Roaming\Typora\typora-user-images\image-20220827100904063.png)

Core i7的地址翻译的概况如下图所示：

![image-20220827100943566](C:\Users\10332\AppData\Roaming\Typora\typora-user-images\image-20220827100943566.png)

由图中可见，TLB和多级页表是虚拟寻址的，而各级cache和主存是通过物理地址进行寻址的。

内核中的地址翻译与数据查找过程如下：CPU产生的虚拟地址先分割为VPN和VPO，VPN进行TLB查找，如果命中则直接返回TLB中的PPN，如果不命中则再将VPN进行分割去查找多级页表。得到PPN后与VPO组合成为物理地址，在cache中进行查找，如果命中则返回数据给CPU，如果不命中则在低级存储中再次查找。

Core i7使用了四级页表，页表中包含若干控制位信息，如可读可写，修改位（脏页）等。

优化地址翻译：可以通过规划VPO的位数来匹配cache的组数，这样在发送的过程中，VPO部分可以直接发送至cache中进行组寻址，而经过MMU得到的PPN只作为标记域来等待匹配，加快了地址翻译。

### 9.7.2 Linux 虚拟内存系统

1. Linux虚拟内存区域

   Linux将虚拟内存组成一些**区域**的集合，一个**区域**就是已经存在着的虚拟内存的连续片，这些页是以某种方式相关联的。例如，代码段、数据段、堆、共享库段。每个存在的虚拟页面都属于某个段，不存在不属于某个段的虚拟页面。

   内核为系统中的每个进程维护一个单独的任务结构task_struct，任务结构中的元素包含或者指向该进程所需要的所有信息。其中一个条目指向mm_struct，它描述了虚拟内存的当前状态。我们感兴趣的两个字段是pgd和mmap，前者指向第一级页表的基址，而mmap指向一个vm_area_structs的链表，每个vm_area_structs都描述了当前虚拟地址空间的一个区域。该结构体中包含如下字段：

   vm_start：段的起始处

   vm_end：段的结束处

   vm_prot：描述该段中所有页的读写许可权限

   vm_flags：描述该段是私有的还是共享的等信息

   vm_next：链表中的下一项

2. Linux缺页异常处理

   内核的缺页处理程序执行以下步骤：

   1. 比较区域结构的链表中的起始地址和结束地址，判断该虚拟地址是否是一个合法的地址。如果不合法，则抛出一个段错误。
   2. 判断该合法地址处的内存访问是否合法，如是否有读写权限等。如果访问非法，则抛出一个段错误。
   3. 如果地址和访问均为合法，则选择一个牺牲页面换出，换入新的页面，更新页表，然后重新启动引发缺页异常的指令。

## 9.8 内存映射

Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射。虚拟内存区域可以映射到两种类型的对象中的一种：

1. Linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分，按页大小进行划分，按需进行调度，没有真正进入物理内存。
2. 匿名文件：匿名文件是由内核创建，包含的全是二进制零，也叫**请求二进制零的文件**，可以初始化一些全为0的页面，如.bss。

无论在那种情况中，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的**交换文件**之间换来换去。

### 9.8.1 再看共享对象

共享的文件（如printf函数文件）映射到不同进程的虚拟内存区域，索引至一块相同的物理内存，这样就能在不同的进程之间共享宝贵的内存资源。

由于每个对象都有一个唯一的文件名，内核可以迅速的判定进程1已经映射了这个对象，而且可以使进程2中的页表条目指向相应的物理界面。如此一来，即使对象被映射到了多个共享区域，物理内存中也只需要存放共享对象的一个副本。

相对于共享对象来说的是私有对象。私有对象使用一种叫做写时复制的巧妙技术被映射到虚拟内存中。当一个私有对象被两个进程使用时，其中一个试图写该对象中的一个页时，会触发一个保护故障，该故障会导致内核创建一个被写页面的复制，将该复制的页面对应的页表项更新为新的物理内存地址。

### 9.8.2 再看fork函数

fork函数在复制进程时会将数据完全复制，但是只创建进程的各种数据结构，但是页面并不复制，而是使用写时复制的技术来保证两个进程的数据是互不干扰的。

### 9.8.3 再看execve函数

### 9.8.4 使用mmap函数的用户级内存映射

mmap函数要求内核拆u你构建一个新的虚拟内存区域，最好是从地址start开始的一个区域，并将文件描述符fd指定的对象的一个连续的片映射到这个新的区域。连续的对象片大小为length字节，从距离文件开始处偏移量为offset字节的地方开始。start通常为NULL。参数prot包含描述新映射的虚拟内存区域和访问权限位。

munmap函数会删除虚拟内存的区域。

## 9.9 动态内存分配

动态内存分配器可以用于创建和删除虚拟内存的区域。

动态内存分配器维护着一个进程的虚拟内存区域，被称为堆（heap）。内核维护一个变量brk指向对的顶部。

分配器将堆视为一种不同的大小的块的集合来维护，每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。

分配器有两种基本风格，两种风格都要求应用显式地分配块，他们的不同之处在于由那个实体来负责释放已分配的块。

**显示分配器**：malloc与free/new与delete

**隐式分配器**：自动释放未使用的已分配的块，也成为垃圾收集器。

### 9.9.1 malloc 和 free函数

malloc函数返回一个指针，指向大小至少为size字节的内存块，这个块会为可能包含在这个块内的任何数据对象类型做对其。事实上对齐依赖于编译环境是32位还是64位，前者块的地址总是8的倍数，后者总是16的倍数。如果malloc函数遇到问题会返回null并设置errno。

malloc并不初始化内存块。想要初始化内存可以使用calloc，将内存块全部初始化为0。

动态内存分配器还有一个函数名为sbrk函数，通过修改内核指针的大小来扩展和收缩堆。如果成功，则返回brk的旧值，否则就返回-1并设置errno。

free函数接收一个指针参数，指向一个由malloc函数分配的内存块的起始地址。否则free函数的行为是未定义的。

### 9.9.2 为什么要使用动态内存分配

程序使用动态内存分配的最重要的原因是经常知道程序实际运行时，才知道某些数据结构的大小。

### 9.9.3 分配器的要求和目标

显式分配器必须在一些相当严格的约束条件下工作：

1. 处理任意请求序列。因此，分配器不可以假设分配和释放请求的顺序。
2. 立即响应请求。因此不允许分配器为了提高性能而重新排列或者缓冲请求。
3. 只使用堆。
4. 对其要求
5. 不修改已分配的快。

在这些限制条件下，实现两个目的：

1. 最大化吞吐率：单位时间内完成的请求数尽可能变多。
2. 最大化内存利用率：虚拟内存也并不是无限的资源，必须高效地使用。

### 9.9.4 碎片

造成堆利用率很低的主要原因时一种称为碎片的现象。分为内部碎片和外部碎片。

**内部碎片：**有效载荷小于所分配的块时发生，造成的原因有很多，如对齐要求。内部碎片的数量只取决于以前请求的模式和分配器的实现方式。

**外部碎片：**是当空闲内存合计起来足够满足一个分配要求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生的。量化更复杂，不仅取决于以前请求的模式和分配器的实现方式，还取决于将来的请求的模式。

因为外部碎片难以量化且不可预测，所以分配器通常采用启发式策略来试图维持少量的大空闲块，而不是维持大量的小空闲块。

### 9.9.5 实现问题

一个实际的分配器要在吞吐率和利用率之间把握好平很，就必须考虑以下几个问题：

1. 如何记录空闲块？
2. 如何选择一个合适的空闲块来放置一个新分配的块？
3. 如何处理空闲块中的剩余部分？
4. 如何处理一个刚刚被释放的块？

### 9.9.6 隐式空闲链表

使用一种块结构来记录内存块的信息。

![image-20220827142857221](C:\Users\10332\AppData\Roaming\Typora\typora-user-images\image-20220827142857221.png)

用一个四字节的头部来表示块大小和块的分配情况。块大小是包含头部的四个字节的。在堆中的对其要求是对于有效载荷来说的。

分配器可以通过遍历堆中所有的块从而间接的遍历整个空闲块的集合。这种方式需要某种特殊标记的结束快，在示例中是一个设置了已分配但是大小为0的终止头部。

隐式空闲链表的特点是简单，缺点是任何操作都是与块总数呈线性的关系。且由最小的块大小要求。

### 9.9.7 放置已经分配的块

分配器搜索空闲链表，找到一个足够大可以防止所请求块的空闲块。分配器执行这种搜索的方式是由防治策略确定的，常见的策略有**首次适配、下一次适配、最佳适配**。

**首次适配：**从头开始搜索空闲链表，直到找到第一个适配的空闲块。

**下一次适配：**与首次适配类似，但是起点是上一次搜索的结束位置。

**最佳适配：**搜索完整链表，找到满足条件的空闲块的最小值。

### 9.9.8 分割空闲块

一旦分配器找到一个匹配的空闲块，他就必须做另一个策略决定，分配该块中多少空间。一个选择是用整个空闲块，优点是简单，缺点是造成内部碎片。另一个选择是分割，一部分被分配，剩下部分变为空闲块。

### 9.9.9 获取额外的堆内存

如果找不到合适的空闲块，一个选择是通过合并在内存中物理上相邻的空闲块来船舰一些更大的空闲块，如果还不够就使用sbrk函数请求额外的堆内存，形成更大的空闲块并插入到空闲链表中。

### 9.9.10 合并空闲块

很多小段空闲块如果相邻时，会引起一种现象叫做**假碎片**，即有许多碎片被分割成小的块，满足不了分配的要求。因此必须**合并**相邻的空闲块。对于分配的时机，可以分为**立即合并**和**推迟合并**，分别对应在一个块被释放时立即检查合并和直到一个分配不被满足时再检查整个堆内存进行合并操作。

对于某些访问模式，立即合并会产生抖动现象，反复合并然后马上分割。我们假设使用立即合并，但是实际上快速的分配器会选择某种形式的推迟合并。

### 9.9.11 带边界标记的合并

再空闲块中添加脚部，脚部就是头部的一个副本。这样会很容易查到即将被释放的分配块的前后块的属性。缺点是当操作连续的小块时，会占用内存空间。不过对于已分配的块来说，可以不使用脚部来节省空间。

### 9.9.12 综合：实现一个简单的分配器

该部分内容是实操一个简单的分配器，采用的是简单的**隐式空闲链表+立即边界标记合并**的形式来实现的。由于该部分的实现逻辑和具体细节与本章节对应实验Malloc Lab是对应的，所以对于本小节的研读放在Malloc Lab实验记录中。

### 9.9.13 显式空闲链表

一种更好的方法时将空闲块组织为某种形式的显式数据结构。因为根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。例如堆可以组织成一个双向空闲链表，在每个空闲块中，都包含一个pred前驱和succ后继指针。

使用双向链表而不是隐式空闲链表，使得首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过释放块的时间取决于空闲链表中块的排序策略。

一种方法是后进先出的顺序，将新释放的块放置在链表的开始处。时间更快。

另一种方法是按照地支顺序来维护链表。内存利用率更高。

### 9.9.14 分离的空闲链表

另一种方式是维护多个空闲链表，其中每个链表中的块有大致相等的大小，一般的思路是将所有可能的大小分成一些等价类，也叫做大小类。

1. 简单分离存储：每个大小类的空闲链表包含大小相等的块，每个块的大小就是这个大小类中最大元素的大小。优点是快，不进行分割和合并，缺点是容易造成内部碎片和外部碎片。

2. 分离适配：分配器维护着一个空闲链表的数组，每个空闲链表是和一个大小类关联的，并且被组织成某种类型的显式或者隐式链表。每个链表包含潜在的大小不同的快，这些块的大小是大小类的成员。

   一种简单的版本如下：

   确定请求的大小类，并且对适当的空闲链表做首次适配，查找一个合适的块。如果找到了一个，就分割它，并将剩余的部分插入到适当的空闲链表中。如果找不到合适的块，那么就搜索下一个更大的大小类的空闲链表。如此重复，直到找到一个合适的块。如果空闲链表中没有合适的块，就向操作系统请求额外的堆内存。从这个新的堆内存中分配出一个块，将剩余部分放置在适当的大小类中。要释放一个块，我们执行合并，并将结果放置到相应的空闲链表中。

3. 伙伴系统：是分离适配的一种特例，将整个堆内存二分的进行查找合适大小的块，并将分割出来的块插入到空闲链表中。由于其是二分查找，其最后得到的大小恰好相等的块必定存在一个大小相同的块，被称为**伙伴**。两个块的地址只有1位是不同的。伙伴系统不是一个通用的分配器，但是在特定的工作负载上会有比较好的表现。

## 9.10 垃圾收集

使用malloc分配的内存不进行释放是一种常见的编程错误。如以下函数：

```c
void garbage(){
    int *p = (int*)Malloc(15213);
    
    return ;
}
```

在该函数中，划分了函数但是没有回收这部分内存，这一部分内存就占用着堆中的内存资源，但是没有函数使用到这一块内存。

**垃圾收集器**是一种动态内存分配器，它自动释放程序不再需要的已分配块，这些块被称为垃圾。自动回收堆存储的过程叫做垃圾收集。

### 9.10.1 垃圾收集器的基本知识

垃圾收集器将内存视作一张有向可达图，包括根节点和堆节点，根节点是在堆内存外的变量中包含指向堆内存的部分，堆节点是一些已分配的块，堆节点之间的边表示块中包含指向堆中别处的节点。如果有一个节点是不可达的，则该节点就是垃圾。垃圾收集器的角色是维护可达图的某种表示，并通过释放不可达节点且将他们返回给空闲链表来定期回收他们。

ML和Java的垃圾收集器能够维护可达图的精确表示，因此能够自动回收所有垃圾。然而诸如C语言的收集器通常不能维持可达图的精确表示，这样的收集器也叫做保守的垃圾收集器。保守的概念理解为：**可达的节点一定是可达的，但是不可达的节点可能会被认为是可达的。**

### 9.10.2 Mark&Sweep垃圾收集器

由标记Mark阶段和清除阶段Sweep组成。标记阶段标记处节点的所有可达的和已分配的后继，而后面的清楚阶段释放每个未被标记的已分配块。块头部中空闲的低位中的一位通常用来表示这个快是否被标记了。

mark函数对每一个节点检查是否被标记，并递归的在其指向的堆节点中来调用该函数。

sweep函数遍历堆内存，释放所有未标记的已分配块。

### 9.10.3 C程序的保守Mark&Sweep

M&S方法是一种好的方法，但是C语言为isPtr函数（作用为返回参数p指向的字所在的块的起始地址，否则返回NULL）的实现提供了一些挑战。第一，C语言不适用数据类型标记内存，所以没有明显的方式来判断参数是否是一个指针。第二，即使我们知道p是一个指针，页没有明显的方式来判断p是否指向一个已分配块的有效载荷中的某个有效位置。

后者的解决办法是将已分配块集合维护成一棵平衡二叉树。该树中左子树中的块都放在较小的地址处，右子树中的所有块都放在较大的地址处。参数p的地址可以在树中进行二分查找来确定在块中。

c程序的M&S必须是保守的，根本原因在于C语言不会使用类型信息来标记内存位置。int可以伪装做一个指针来当作参数，函数无法分别，所以将块保守的标记为可达。

## 9.11 C程序中常见的与内存有关的错误

## 9.11.1 间接引用坏指针

引用指向空的或者写只读的区域会导致保护异常终止这个程序。例如scanf函数传入变量而非地址，将变量的值解析为地址，容易导致异常甚至更隐秘的错误。

### 9.11.2 读未初始化的内存

malloc得到的内存区域的初始值是未知的，因此假定其值为0进行使用是危险的行为。可以使用calloc来避免出错。

### 9.11.3 允许缓冲区溢出

老生常谈

### 9.11.4 假设指针和它们指向的对象是相同大小的

一个实例程序：

```c
int **makeArray(int n,int m){
    int i;
    int **A = (int **)Malloc(n * sizeof(int));
    
    for(i=0;i<n;i++)
        A[i] = (int *)Malloc(m * sizeof(int));
    return A;
}
```

在一个64位的机器上，int* 是8字节，int是4字节，第二行的声明值声明了我们期望大小的一半。

### 9.11.5 造成错位错误

错位（off-by-one）错误是另一种很常见的造成覆盖错误的来源。

```c
int **makeArray2(int n,int m){
    int i ;
    int **A = (int**)Malloc(n * sizeof(int *));
    
    for(i=0;i<=n;i++)
        A[i] = (int *)Malloc(m * sizeof(int));
    return A;
}
```

数组的越界访问，覆盖了数组后的一个位置。

### 9.11.6 引用指针而不是它所指向的对象

如果size是一个int*指针，则

```c
*(size--);
*size--;
```

二者是完全不同的。

### 9.11.7 误解指针运算

指针的运算是以所指向的对象的数据大小为单位的，p+1实际上地址的值加了4（以int类型为例）

### 9.11.8 引用不存在的变量

如一个函数中返回一个存放在栈中的局部变量的地址，这是一个非法的行为。

### 9.11.9 引用空闲堆块中的数据

一个块被释放后，重新使用原本指向该块的指针进行数据引用，会出现不可预知的错误。

### 9.11.10 引起内存泄漏

例如在函数中分配堆块但是不释放就返回，则该块会被一直占用。
