# Chapter02 信息的表示和处理

计算机以二进制存储为基础，数字以二进制的形式进行存储。本章考虑三种数字编码的形式：**通过常见的二进制表示的无符号整数unsigned、二进制补码的形式存储的有符号整数以及浮点数编码**。由于表示数字的位数是有限的，因此会出现**溢出overflow**。整数的加法和乘法是满足**交换律和结合律**的，尽管结果可能是溢出的。但是对于**浮点数**，是不满足**结合律的**。如3.14 = 3.14+（1e20-1e20）≠（3.14+1e20）-1e20 = 0.

## 2.1 信息存储

8个比特位组成一个**字节byte**，来作为最小的可寻址的存储器单位（按字节编址），程序将存储器视为一个巨大的字节数组，称为虚拟存储器。按字节编址即每一个字节都有一个唯一的地址来对应和索引。编译器对程序存储的管理完全是在**虚拟地址空间**里完成的。

### 2.1.1 十六进制表示法

以0x或者0X开头的数字常量被认为是十六进制的值。熟练十六进制与二进制、十进制的互转。

### 2.1.2 字 数据大小

字长（word size）表明正数和指针数据的标称大小，虚拟地址的大小也由字长来决定，2^n字节。

不同的数据类型大小不同，而所有的指针类型都使用机器的字长，不随着所指类型的长度变化而变化。

### 2.1.3 寻址和字节顺序

表示一个对象所需的字节在内存中一般是连续存放的，某一字节内部的8个比特的排序必然是固定的，但是不同字节之间的字节序列排序存在大端序和小端序。

小端法（little endian）：在一个对象的内部，最低有效字节在最前面，也就是最低有效字节在较低地址，是与人类的数字阅读习惯相反的。Intel的机器采取的是小端法

大端法（big endian）：在一个对象的内部，最高有效字节在最前面，与人类阅读数字的习惯一致。

程序员对于字节序是不可见的，但是数据流以字节为单位在不同字节序的机器上流动时会出现问题，因此要清楚的规定字节序。第二在反汇编时出现的字节序时按照机器实际字节序来展示的，而其含义为转换后的含义。

### 2.1.4 表示字符串

C语言的字符串是一个字符数组，以null为结尾。strlen（char*）函数不会将结尾的0x00计入。

### 2.1.5 表示代码

相同的程序在不同的机器上编译得到的机器代码不同。本机上所得二进制码与书中所示windows下的不相同。在linux虚拟机下尝试

### 2.1.6 布尔代数简介

围绕数值0和1的研究，来研究逻辑推理的基本原则。简单的一位布尔运算可以扩展到**位向量**的运算。对于布尔环的理解类似于近世代数中的群环域，如存在加法逆元（布尔运算中的加法为^）。

### 2.1.7 C语言中的位级运算

位运算的一个常见用法时实现掩码运算。位运算符包括&、|、~、^

### 2.1.8 C语言中的逻辑运算

与上述位运算不同，逻辑运算符包括||、&&、！，对应or、and、not。逻辑运算符全部存在惰性求值（early terninnate）

### 2.1.9 C语言中的移位运算

移位操作包括算术移位和逻辑移位，其中逻辑移位是将操作数向左或右移动k位，空位由0补充。

对于右移还存在一种算术右移，其填充位与原数的符号位一致。

C语言没有明确的定义，对于有符号数可以进行两种移位，但实际上几乎全部采用算术移位。无符号数的右移必须是逻辑右移。对于Java来说，其算术右移操作符为>>，逻辑右移的操作符为>>>

**当移动的位数超过了操作数的位数时，应当对于移位的位数进行求模操作，一个长度为m的操作数x，移位时只关注移位变量k的低log2 m位。**

本机器的尝试对于int类laishu型是满足条件的，但是对于short类型是不满足的，short类型是16为，而移位量在16-32时结果全部为0。原因在于，发现对于short类型来说，其进行一次移位操作后的返回值是int类型。因此在移位后是合法移位的int类型转换为short类型，自然是全为0.另外，移位操作的优先级是低于加法操作的，因此对于包含移位操作的表达式要注意加括号。

## 2.2 整数表示

T代表补码数，也就是有符号数。U代表无符号数。B代表二进制数

### 2.2.1 整型数据类型

表示整数。其中long类型会根据机器的类型采用4字节或者8字节。对于有符号数来说，能表示的负数个数比正数个数多1.C语言保证整数类型必须保证有对称的正负数取值，也就是说除去最小的负数以外其他的数式必须能够取到的。另外，Java只支持有符号数，C/C++支持有符号数和无符号数。

### 2.2.2 无符号数的编码

从位向量到无符号数的转化，即每一位乘以对应2的幂，且该转化是一个双射，比特长度范围内的无符号数编码是唯一的。

### 2.2.3 补码编码

常见的对于有符号数的编码是**补码**

最高位称为符号位，其权重变为负数。同时补码再范围内也是一个双射，即补码的编码也是唯一的。

 最小的负数的绝对值比最大的正数大一，这是因为表示的负数个数与非负数个数相同而存在0。同理，最大的无符号数比最大的有符号整数的两倍大1.

有符号数还有气压两种标准的表示方法：

1. 反码One‘s complenment：除了最高有效位的权是-（2^(w-1) -1）其他同补码。
2. 源码Sign-Magnitude：最高位是符号位，最高位确定后其他位的权值的正负全部与符号位相同。

两种表示方法都会导致0有两种不同的表示方式。

### 2.2.4 有符号数和无符号数之间的转换

有符号数和无符号数之间的转化是在位级上进行的。强制类型转换结果保持位不变，只是改变了解释这些位的方式。

### 2.2.5 C语言中的有符号数和无符号数

在有符号整数和无符号整数互相赋值时，遵循的原则是底层比特不变。

当有符号数和无符号数同时出现在了运算表达式中，则有符号数会隐式的转变为无符号数，同时结果也会变为无符号数。因此在有关大于和小于这两种操作时，有符号数和无符号数会存在一些与直觉相悖的现象。

在C标准中，Tmax使用实际的值进行宏定义，但是Tmin则是使用Tmax-1来定义。这是因为某些规则，此处参考[C语言中TMin的写法 - 生栋 - 博客园 (cnblogs.com)](https://www.cnblogs.com/Jack47/archive/2013/01/06/TMin32-in-c.html)中的说明，虽然这个数值能够用int类型来表示，但是在C语言中却没法写出对应这个数值的int类型的**常量**。

### 2.2.6 扩展一个数字的位表示

对于一个无符号数，只需要在高位补足够的0即可。

对于一个有符号数，需要在高位补符号位的比特。

需要注意的是，对于不同大小的数据类型之间转换，有符号数和无符号数之间的转换的顺序能够应先过一个程序的行为。C语言标准要求要先进性数据大小的转换（即进行位扩展），再进行有无符号数的转换。

### 2.2.7 截断数字

减少一个数字所表示的位数，即截断数字，截取数字的低比特位。截断一个数字可能会改变它的值，这是溢出的一种形式。

截断无符号数等价于对2的整数幂取模，截断有符号数（补码）等价于取模后得到正负的剩余类。

### 2.2.8 关于有符号数与无符号数的建议

关于有符号数和无符号数的隐式转换。详见练习题。

扩展：2002年的FreeBSD漏洞，程序内部的memcpy设置的内存复制长度参数是size_t类型，但是在copy_from_kernel函数中却接收的是int参数，因此一个int类型的长度参数将有机会作为memcpy的长度参数执行函数，但是如果该参数是一个负数，则将转化为一个大的正数，复制过量的内存数据。

无符号数会带来很多麻烦，但是也是有用的，除了C语言之外的其他语言都不支持无符号数。

## 2.3 整数运算

x>y 和 x-y<0会产生不同的结果

### 2.3.1 无符号加法

比特相加进位，可能会出现溢出。C语言的溢出不会作为错误。检测溢出可以将加法结果与加数作比较，两数之和s如果小于加数x和y（二者等价），则说明发生了溢出，推导此处略去。

无符号数加法可以形成阿贝尔群，对应的每一个元素可以有一个加法逆元。方法同补码求相反数。

### 2.3.2 补码加法

补码会发生正溢出或者负溢出。

检测补码加法出现溢出：加数一正一负时不会出现溢出。当加数都为正和为负，或者加数为负和为正时，补码加法出现正/负溢出。

### 2.3.2 补码的非

所有位取反再加1即可。注意Tmin的非还是Tmin

### 2.3.4 无符号乘法

相乘再截断

### 2.3.5 补码乘法

补码乘法和无符号乘法的位级表示等价，出去符号位相乘后取模即可。

注意练习题的2.36.其中所表明的使用int64来进行除法溢出的检测，两个int类型相乘赋给一个int64类型需要先将int类型转为int64再进行乘法。否则可能会出错。这是因为两个int相乘再将结果赋给int64是先乘法得到32位结果再进行符号扩展，可能与我们期望不符。

code here

C语言相关设计标准中包含**整数提升**。

XDR库所暴露出的安全漏洞也是一个乘法的溢出问题。

### 2.3.6 乘以常数

乘以常数的操作通过移位操作和加法操作的方式而非乘法指令来进行指令加速。

乘以2的幂：左移k位

乘以常数：有两种方式：

1. 按照位移量每一位为1的比特移位相加，(x<<n)+(x<<(n-1))+...(x<<m)
2. 按照补位，如果有较多连续的1，则从最高位的左侧一个比特的位移量减去最低位比特的位移量，(x<<(n+1))-(x<<m)。

### 2.3.7 除以2的幂

除以2的幂使用右移来实现，对应使用逻辑右移和算术右移。其中对于正数结果向下取整，负数应当向上取整。

而对于通过以为实现的除以2的幂的补码乘法，则采取向下取整，因为仅通过移位实现的除以2的幂会直接截断在整数位内，后面的小数部分不会对结果产生影响，所以会出现向下取整的现象。为了保持一致性，对于补码除法采取添加**偏置**来修正舍入。偏置的值为（1<<k）-1。

### 2.3.8 关于整数运算的最后思考

unsigned类型和补码在比特位级上有相同的表示。关于unsigned要注意使用。

## 2.4 浮点数

### 2.4.1 二进制小数

小数点后的每一位二进制数同样有着其对应的权重，不过幂指数为对应的负数。对于二进制的小数与十进制转化即不断乘二即可。

### 2.4.2 IEEE浮点表示

IEEE标准使用
$$
V = (-1)^{s}*M*2^{E}
$$
来表示一个数。

s为符号位，决定数的正负。

尾数significand：M是一个二进制小数，其范围为1~2-ε或者是0~1-ε。

阶码（exponent）：对浮点数进行加权。权重可能是2的负数次幂。

按照以上部分的作用将浮点数的比特位划分为三个部分，分别对这些值进行编码：

第一个比特是符号位s。k位的exp和n位的小数字段**尾数**frac。

在单精度32比特float类型中，上述三部分为1、8、23位，在双精度64比特double类型中，s、exp、frac分别为1、11、52位。

对于各部分的通常和特殊情况，浮点数共有三种大致分类（以32bit类型为例）：

1. 规格化的值：exp的值介于1和254之间。此时浮点数的E = exp - 127（双精度的该偏移值为1023）.，E的范围为-126~127.frac的值解释为一个二进制小数，M的值为1+f.

2. 非规格化的值：exp的值为全0，此时E = 1-127，而M = f，以此来表示接近0的数值。

   非规格化数有两个用途：其为浮点数提供了表示+0.0和-0.0的方式，即除符号位意外其他位全为0.另外可以表示那些非常接近0的数，和规格数所能表示的范围恰好连接。其有一种叫做**逐渐溢出**的属性，可能的数值分布均匀的接近于0.0。

3. 特殊值

   当阶码值全为1，frac域中的位全为0，此时用来表示无穷大，根据符号位有正无穷大和负无穷大。而当frac域中的数不全为0时，结果被称为NaN，意味Not a number，用于表示一些不能求值的表达式或者未初始化的数据。

### 2.4.3 数字示例

可表示的数在全部范围内并不是均匀分布的，越靠近零点分布越稠密。但是对于非规格化数来说是均匀分布的。而最大的非规格化数和最小的规格化数之间的转变同样是平滑的，这是对于非规格化数采取1-bias的设置得到的。

另外，对于符号位为0的所有数，浮点数的大小和比特位的大小顺序是相同的，因此可以按照整数排序的方式进行。

练习题2.49是一个很有意思的题目。

### 2.4.4 舍入

四种方式：向偶数舍入、向零舍入、向下舍入、向上舍入。其中向偶数舍入是向最近的整数舍入，而对于中间数则向偶数舍入。向偶数舍入的设计再统计情况中避免了因为舍入带来的统计偏差。

### 2.4.5 浮点运算

浮点运算是可交换但是不可结合的。

### 2.4.6 C语言中的浮点数

int float 和double之间的格式转换存在以下原则：（精度和范围分别带来溢出和舍入的问题）

1. int转为float不会溢出，但是会舍入
2. int 或float转为double结果精确保留
3. double转为float可能会溢出，也可能会舍入
4. float或者double转为int，值会向零舍入
