# Chapter02 信息的表示和处理

计算机以二进制存储为基础，数字以二进制的形式进行存储。本章考虑三种数字编码的形式：**通过常见的二进制表示的无符号整数unsigned、二进制补码的形式存储的有符号整数以及浮点数编码**。由于表示数字的位数是有限的，因此会出现**溢出overflow**。整数的加法和乘法是满足**交换律和结合律**的，尽管结果可能是溢出的。但是对于**浮点数**，是不满足**结合律的**。如3.14 = 3.14+（1e20-1e20）≠（3.14+1e20）-1e20 = 0.

## 2.1 信息存储

8个比特位组成一个**字节byte**，来作为最小的可寻址的存储器单位（按字节编址），程序将存储器视为一个巨大的字节数组，称为虚拟存储器。按字节编址即每一个字节都有一个唯一的地址来对应和索引。编译器对程序存储的管理完全是在**虚拟地址空间**里完成的。

### 2.1.1 十六进制表示法

以0x或者0X开头的数字常量被认为是十六进制的值。熟练十六进制与二进制、十进制的互转。

### 2.1.2 字 数据大小

字长（word size）表明正数和指针数据的标称大小，虚拟地址的大小也由字长来决定，2^n字节。

不同的数据类型大小不同，而所有的指针类型都使用机器的字长，不随着所指类型的长度变化而变化。

### 2.1.3 寻址和字节顺序

表示一个对象所需的字节在内存中一般是连续存放的，某一字节内部的8个比特的排序必然是固定的，但是不同字节之间的字节序列排序存在大端序和小端序。

小端法（little endian）：在一个对象的内部，最低有效字节在最前面，也就是最低有效字节在较低地址，是与人类的数字阅读习惯相反的。Intel的机器采取的是小端法

大端法（big endian）：在一个对象的内部，最高有效字节在最前面，与人类阅读数字的习惯一致。

程序员对于字节序是不可见的，但是数据流以字节为单位在不同字节序的机器上流动时会出现问题，因此要清楚的规定字节序。第二在反汇编时出现的字节序时按照机器实际字节序来展示的，而其含义为转换后的含义。

### 2.1.4 表示字符串

C语言的字符串是一个字符数组，以null为结尾。strlen（char*）函数不会将结尾的0x00计入。

### 2.1.5 表示代码

相同的程序在不同的机器上编译得到的机器代码不同。本机上所得二进制码与书中所示windows下的不相同。在linux虚拟机下尝试

### 2.1.6 布尔代数简介

围绕数值0和1的研究，来研究逻辑推理的基本原则。简单的一位布尔运算可以扩展到**位向量**的运算。对于布尔环的理解类似于近世代数中的群环域，如存在加法逆元（布尔运算中的加法为^）。

### 2.1.7 C语言中的位级运算

位运算的一个常见用法时实现掩码运算。位运算符包括&、|、~、^

### 2.1.8 C语言中的逻辑运算

与上述位运算不同，逻辑运算符包括||、&&、！，对应or、and、not。逻辑运算符全部存在惰性求值（early terninnate）

### 2.1.9 C语言中的移位运算

移位操作包括算术移位和逻辑移位，其中逻辑移位是将操作数向左或右移动k位，空位由0补充。

对于右移还存在一种算术右移，其填充位与原数的符号位一致。

C语言没有明确的定义，对于有符号数可以进行两种移位，但实际上几乎全部采用算术移位。无符号数的右移必须是逻辑右移。对于Java来说，其算术右移操作符为>>，逻辑右移的操作符为>>>

**当移动的位数超过了操作数的位数时，应当对于移位的位数进行求模操作，一个长度为m的操作数x，移位时只关注移位变量k的低log2 m位。**

本机器的尝试对于int类laishu型是满足条件的，但是对于short类型是不满足的，short类型是16为，而移位量在16-32时结果全部为0。原因在于，发现对于short类型来说，其进行一次移位操作后的返回值是int类型。因此在移位后是合法移位的int类型转换为short类型，自然是全为0.

